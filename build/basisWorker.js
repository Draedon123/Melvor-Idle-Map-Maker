(()=>{"use strict";({600:function(){var e=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(o,c){function a(e){try{s(n.next(e))}catch(e){c(e)}}function i(e){try{s(n.throw(e))}catch(e){c(e)}}function s(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,i)}s((n=n.apply(e,t||[])).next())}))};importScripts("basis_encoder.js"),e(void 0,void 0,void 0,(function*(){function t(){return e(this,void 0,void 0,(function*(){return BASIS()}))}self.addEventListener("message",(r=>e(void 0,void 0,void 0,(function*(){const{data:e}=r,n=yield t();if("encode"===e.mode){const{BasisEncoder:c,initializeBasis:a}=n;for(const i of e.data){const s=yield i.texture.arrayBuffer();a();const T=new Uint8Array(10485760);let _;const u=new c;u.setSliceSourceImage(0,new Uint8Array(s),0,0,!0),u.setDebug(!1),u.setComputeStats(!1),u.setPerceptual(!0),u.setMipSRGB(!0),u.setQualityLevel(255),u.setUASTC(!0),u.setMipGen(!1),_=u.encode(T);const R=new Uint8Array(T.buffer,0,_);if(u.delete(),0===_)return postMessage({error:"Failed to convert image to basis",status:"error"});postMessage({name:i.name,texture:R})}return}if("transcode"===e.mode){let l;!function(e){e[e.cTFETC1=0]="cTFETC1",e[e.cTFETC2=1]="cTFETC2",e[e.cTFBC1=2]="cTFBC1",e[e.cTFBC3=3]="cTFBC3",e[e.cTFBC4=4]="cTFBC4",e[e.cTFBC5=5]="cTFBC5",e[e.cTFBC7=6]="cTFBC7",e[e.cTFPVRTC1_4_RGB=7]="cTFPVRTC1_4_RGB",e[e.cTFPVRTC1_4_RGBA=8]="cTFPVRTC1_4_RGBA",e[e.cTFASTC_4x4=9]="cTFASTC_4x4",e[e.cTFATC_RGB=10]="cTFATC_RGB",e[e.cTFATC_RGBA_INTERPOLATED_ALPHA=11]="cTFATC_RGBA_INTERPOLATED_ALPHA",e[e.cTFRGBA32=12]="cTFRGBA32",e[e.cTFRGB565=13]="cTFRGB565",e[e.cTFBGR565=14]="cTFBGR565",e[e.cTFRGBA4444=15]="cTFRGBA4444",e[e.cTFFXT1_RGB=16]="cTFFXT1_RGB",e[e.cTFPVRTC2_4_RGB=17]="cTFPVRTC2_4_RGB",e[e.cTFPVRTC2_4_RGBA=18]="cTFPVRTC2_4_RGBA",e[e.cTFETC2_EAC_R11=19]="cTFETC2_EAC_R11",e[e.cTFETC2_EAC_RG11=20]="cTFETC2_EAC_RG11"}(l||(l={}));const E=37808,F=33776,d=33779,B=36492,A=36196,f=35840,C=35842,g=new Map([[l.cTFBC1,F],[l.cTFBC3,d],[l.cTFBC7,B]]),{BasisFile:m,initializeBasis:p}=n,G=e.canvas,x=G.getContext("webgl"),v=null!==x;if(!v)return postMessage({error:"WebGL not supported",status:"error"});const P=!!x.getExtension("WEBGL_compressed_texture_astc"),U=!!x.getExtension("WEBGL_compressed_texture_etc1"),b=!!x.getExtension("WEBGL_compressed_texture_s3tc"),L=!!x.getExtension("WEBGL_compressed_texture_pvrtc")||!!x.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),S=!!x.getExtension("EXT_texture_compression_bptc"),h={},I={};let y,w;if(v){if(w=x.createBuffer(),null===w)throw new Error("Could not create WebGL buffer");function M(e,t){const r=x.createShader(t);if(null===r)throw new Error("Could not create WebGL shader");return x.shaderSource(r,e),x.compileShader(r),(null==x?void 0:x.getShaderParameter(r,x.COMPILE_STATUS))||console.log(x.getShaderInfoLog(r)),r}x.bindBuffer(x.ARRAY_BUFFER,w),x.bufferData(x.ARRAY_BUFFER,new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),x.STATIC_DRAW);const X=M("\n          precision highp float;\n          attribute vec4 position;\n          varying vec2 varyingUV;\n          void main(){\n            gl_Position = vec4(position.xy, 0.0, 1.0);\n            varyingUV = position.zw;\n          }\n        ",x.VERTEX_SHADER),W=M("\n          precision highp float;\n          uniform sampler2D textureSampler;\n          uniform vec4 control;\n          varying vec2 varyingUV;\n          void main(){\n            vec4 colour;\n            colour = texture2D(textureSampler, varyingUV);\n            if(control.x > 0.0){\n              colour.w = 1.0;\n            }\n            else if(control.y > 0.0){\n              colour.rgb = colour.aaa;\n              colour.w = 1.0;\n            }\n            gl_FragColor = colour;\n          }\n        ",x.FRAGMENT_SHADER);if(y=x.createProgram(),null===y)throw new Error("Could not create WebGL program");x.attachShader(y,X),x.attachShader(y,W),x.linkProgram(y),x.useProgram(y);const N=x.getAttribLocation(y,"position");x.bindAttribLocation(y,N,"position"),x.enableVertexAttribArray(N),x.enable(x.DEPTH_TEST),x.disable(x.CULL_FACE);let O=x.getProgramParameter(y,x.ACTIVE_UNIFORMS);for(let k=0;k<O;k++){const z=x.getActiveUniform(y,k),Y=x.getUniformLocation(y,z.name);h[z.name]=Y}let H=x.getProgramParameter(y,x.ACTIVE_ATTRIBUTES);for(let j=0;j<H;j++){const q=x.getActiveUniform(y,j),K=x.getAttribLocation(y,q.name);I[q.name]=K}}function D(e,t,r,n){if(!v)return"WebGL not supported";const o=x.createTexture();return null===o?"Could not create WebGL texture":(x.bindTexture(x.TEXTURE_2D,o),e instanceof Uint8Array?x.compressedTexImage2D(x.TEXTURE_2D,0,n,t,r,0,e):x.texImage2D(x.TEXTURE_2D,0,x.RGB,t,r,0,x.RGB,x.UNSIGNED_SHORT_5_6_5,e),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MAG_FILTER,x.LINEAR),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MIN_FILTER,x.LINEAR),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_WRAP_S,x.CLAMP_TO_EDGE),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_WRAP_T,x.CLAMP_TO_EDGE),x.bindTexture(x.TEXTURE_2D,null),o)}function V(e,t,r){v&&(x.clearColor(0,0,0,1),x.clearDepth(1),x.viewport(0,0,t,r),x.clear(x.COLOR_BUFFER_BIT|x.DEPTH_BUFFER_BIT|x.STENCIL_BUFFER_BIT),x.activeTexture(x.TEXTURE0),x.bindTexture(x.TEXTURE_2D,e),x.uniform1i(h.textureSampler,0),x.uniform4f(h.control,0,0,0,0),x.enableVertexAttribArray(I.position),x.bindBuffer(x.ARRAY_BUFFER,w),x.vertexAttribPointer(I.position,4,x.FLOAT,!1,0,0),x.drawArrays(x.TRIANGLE_STRIP,0,4))}for(const Q of e.data){const{name:$,file:J}=Q;p();const Z=new m(new Uint8Array(yield J.arrayBuffer())),ee=Z.getImageWidth(0,0),te=Z.getImageHeight(0,0),re=Z.getHasAlpha();if(!ee||!te)return postMessage({error:"Invalid basis file",status:"error"});const ne=P?l.cTFASTC_4x4:S?l.cTFBC7:b?re?l.cTFBC3:l.cTFBC1:L?re?l.cTFPVRTC1_4_RGBA:l.cTFPVRTC1_4_RGB:U?l.cTFETC1:l.cTFRGB565;if(!(ne!==l.cTFPVRTC1_4_RGBA&&ne!==l.cTFPVRTC1_4_RGB||0==(ee&ee-1)&&0==(te&te-1)&&ee===te))return postMessage({error:"PVRTC1 requires square power of 2 textures",status:"error"});if(!Z.startTranscoding())return Z.close(),Z.delete(),postMessage({error:"Transcoding failed",status:"error"});const oe=new Uint8Array(Z.getImageTranscodedSizeInBytes(0,0,ne));if(!Z.transcodeImage(oe,0,0,ne,0,0)&&!Z.startTranscoding())return Z.close(),Z.delete(),postMessage({error:"Transcoding failed",status:"error"});Z.close(),Z.delete();const ce=ee+3&-4,ae=te+3&-4;let ie,se=ce,Te=ae;switch(G.width=ce,G.height=ae,ne){case l.cTFASTC_4x4:ie=D(oe,ce,ae,E);break;case l.cTFBC1:case l.cTFBC3:case l.cTFBC7:ie=D(oe,ce,ae,g.get(ne));break;case l.cTFETC1:ie=D(oe,ce,ae,A);break;case l.cTFPVRTC1_4_RGB:ie=D(oe,ce,ae,f);break;case l.cTFPVRTC1_4_RGBA:ie=D(oe,ce,ae,C);break;default:G.width=ee,G.height=te,se=ee,Te=te;const Re=new Uint16Array(ee*te);let le=0;for(let Ee=0;Ee<te;Ee++)for(let Fe=0;Fe<ee;Fe++,le++)Re[le]=oe[2*le]|oe[2*le+1]<<8;ie=D(Re,ee,te)}if("string"==typeof ie)return postMessage({error:ie,status:"error"});V(ie,se,Te);const _e=yield G.convertToBlob(),ue=URL.createObjectURL(_e);postMessage({name:$,blobURL:ue})}return}const o={error:`Invalid mode. Expected: "encode" or "transcode". Received: ${null==e?void 0:e.mode}`,status:"error"};postMessage(o)}))))}))}})[600]()})();